This is ginac.info, produced by makeinfo version 4.5 from
/user/jensv/ginac/ginac/doc/tutorial/ginac.texi.

INFO-DIR-SECTION Mathematics
START-INFO-DIR-ENTRY
* ginac: (ginac).                   C++ library for symbolic computation.
END-INFO-DIR-ENTRY

This is a tutorial that documents GiNaC 1.4.3, an open framework for
symbolic computation within the C++ programming language.

Copyright (C) 1999-2008 Johannes Gutenberg University Mainz, Germany

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.


File: ginac.info,  Node: Constants,  Next: Fundamental containers,  Prev: Numbers,  Up: Basic concepts

Constants
=========

Constants behave pretty much like symbols except that they return some
specific number when the method `.evalf()' is called.

The predefined known constants are:

*Name*     *Common Name*           *Numerical Value (to 35 digits)*
`Pi'       Archimedes' constant    3.14159265358979323846264338327950288
`Catalan'  Catalan's constant      0.91596559417721901505460351493238411
`Euler'    Euler's (or             0.57721566490153286060651209008240243
           Euler-Mascheroni)       
           constant                


File: ginac.info,  Node: Fundamental containers,  Next: Lists,  Prev: Constants,  Up: Basic concepts

Sums, products and powers
=========================

Simple rational expressions are written down in GiNaC pretty much like
in other CAS or like expressions involving numerical variables in C.
The necessary operators `+', `-', `*' and `/' have been overloaded to
achieve this goal.  When you run the following code snippet, the
constructor for an object of type `mul' is automatically called to hold
the product of `a' and `b' and then the constructor for an object of
type `add' is called to hold the sum of that `mul' object and the
number one:

         ...
         symbol a("a"), b("b");
         ex MyTerm = 1+a*b;
         ...

For exponentiation, you have already seen the somewhat clumsy (though
C-ish) statement `pow(x,2);' to represent `x' squared.  This direct
construction is necessary since we cannot safely overload the
constructor `^' in C++ to construct a `power' object.  If we did, it
would have several counterintuitive and undesired effects:

   * Due to C's operator precedence, `2*x^2' would be parsed as
     `(2*x)^2'.

   * Due to the binding of the operator `^', `x^a^b' would result in
     `(x^a)^b'. This would be confusing since most (though not all)
     other CAS interpret this as `x^(a^b)'.

   * Also, expressions involving integer exponents are very frequently
     used, which makes it even more dangerous to overload `^' since it
     is then hard to distinguish between the semantics as
     exponentiation and the one for exclusive or.  (It would be
     embarrassing to return `1' where one has requested `2^3'.)

All effects are contrary to mathematical notation and differ from the
way most other CAS handle exponentiation, therefore overloading `^' is
ruled out for GiNaC's C++ part.  The situation is different in `ginsh',
there the exponentiation-`^' exists.  (Also note that the other
frequently used exponentiation operator `**' does not exist at all in
C++).

To be somewhat more precise, objects of the three classes described
here, are all containers for other expressions.  An object of class
`power' is best viewed as a container with two slots, one for the
basis, one for the exponent.  All valid GiNaC expressions can be
inserted.  However, basic transformations like simplifying
`pow(pow(x,2),3)' to `x^6' automatically are only performed when this
is mathematically possible.  If we replace the outer exponent three in
the example by some symbols `a', the simplification is not safe and
will not be performed, since `a' might be `1/2' and `x' negative.

Objects of type `add' and `mul' are containers with an arbitrary number
of slots for expressions to be inserted.  Again, simple and safe
simplifications are carried out like transforming `3*x+4-x' to `2*x+4'.


File: ginac.info,  Node: Lists,  Next: Mathematical functions,  Prev: Fundamental containers,  Up: Basic concepts

Lists of expressions
====================

The GiNaC class `lst' serves for holding a "list" of arbitrary
expressions. They are not as ubiquitous as in many other computer
algebra packages, but are sometimes used to supply a variable number of
arguments of the same type to GiNaC methods such as `subs()' and some
`matrix' constructors, so you should have a basic understanding of them.

Lists can be constructed by assigning a comma-separated sequence of
expressions:

     {
         symbol x("x"), y("y");
         lst l;
         l = x, 2, y, x+y;
         // now, l is a list holding the expressions 'x', '2', 'y', and 'x+y',
         // in that order
         ...

There are also constructors that allow direct creation of lists of up to
16 expressions, which is often more convenient but slightly less
efficient:

         ...
         // This produces the same list 'l' as above:
         // lst l(x, 2, y, x+y);
         // lst l = lst(x, 2, y, x+y);
         ...

Use the `nops()' method to determine the size (number of expressions) of
a list and the `op()' method or the `[]' operator to access individual
elements:

         ...
         cout << l.nops() << endl;                // prints '4'
         cout << l.op(2) << " " << l[0] << endl;  // prints 'y x'
         ...

As with the standard `list<T>' container, accessing random elements of a
`lst' is generally an operation of order O(N). Faster read-only
sequential access to the elements of a list is possible with the
iterator types provided by the `lst' class:

     typedef ... lst::const_iterator;
     typedef ... lst::const_reverse_iterator;
     lst::const_iterator lst::begin() const;
     lst::const_iterator lst::end() const;
     lst::const_reverse_iterator lst::rbegin() const;
     lst::const_reverse_iterator lst::rend() const;

For example, to print the elements of a list individually you can use:

         ...
         // O(N)
         for (lst::const_iterator i = l.begin(); i != l.end(); ++i)
             cout << *i << endl;
         ...

which is one order faster than

         ...
         // O(N^2)
         for (size_t i = 0; i < l.nops(); ++i)
             cout << l.op(i) << endl;
         ...

These iterators also allow you to use some of the algorithms provided by
the C++ standard library:

         ...
         // print the elements of the list (requires #include <iterator>)
         std::copy(l.begin(), l.end(), ostream_iterator<ex>(cout, "\n"));
     
         // sum up the elements of the list (requires #include <numeric>)
         ex sum = std::accumulate(l.begin(), l.end(), ex(0));
         cout << sum << endl;  // prints '2+2*x+2*y'
         ...

`lst' is one of the few GiNaC classes that allow in-place modifications
(the only other one is `matrix'). You can modify single elements:

         ...
         l[1] = 42;       // l is now {x, 42, y, x+y}
         l.let_op(1) = 7; // l is now {x, 7, y, x+y}
         ...

You can append or prepend an expression to a list with the `append()'
and `prepend()' methods:

         ...
         l.append(4*x);   // l is now {x, 7, y, x+y, 4*x}
         l.prepend(0);    // l is now {0, x, 7, y, x+y, 4*x}
         ...

You can remove the first or last element of a list with `remove_first()'
and `remove_last()':

         ...
         l.remove_first();   // l is now {x, 7, y, x+y, 4*x}
         l.remove_last();    // l is now {x, 7, y, x+y}
         ...

You can remove all the elements of a list with `remove_all()':

         ...
         l.remove_all();     // l is now empty
         ...

You can bring the elements of a list into a canonical order with
`sort()':

         ...
         lst l1, l2;
         l1 = x, 2, y, x+y;
         l2 = 2, x+y, x, y;
         l1.sort();
         l2.sort();
         // l1 and l2 are now equal
         ...

Finally, you can remove all but the first element of consecutive groups
of elements with `unique()':

         ...
         lst l3;
         l3 = x, 2, 2, 2, y, x+y, y+x;
         l3.unique();        // l3 is now {x, 2, y, x+y}
     }


File: ginac.info,  Node: Mathematical functions,  Next: Relations,  Prev: Lists,  Up: Basic concepts

Mathematical functions
======================

There are quite a number of useful functions hard-wired into GiNaC.  For
instance, all trigonometric and hyperbolic functions are implemented
(*Note Built-in functions::, for a complete list).

These functions (better called _pseudofunctions_) are all objects of
class `function'.  They accept one or more expressions as arguments and
return one expression.  If the arguments are not numerical, the
evaluation of the function may be halted, as it does in the next
example, showing how a function returns itself twice and finally an
expression that may be really useful:

         ...
         symbol x("x"), y("y");
         ex foo = x+y/2;
         cout << tgamma(foo) << endl;
          // -> tgamma(x+(1/2)*y)
         ex bar = foo.subs(y==1);
         cout << tgamma(bar) << endl;
          // -> tgamma(x+1/2)
         ex foobar = bar.subs(x==7);
         cout << tgamma(foobar) << endl;
          // -> (135135/128)*Pi^(1/2)
         ...

Besides evaluation most of these functions allow differentiation, series
expansion and so on.  Read the next chapter in order to learn more about
this.

It must be noted that these pseudofunctions are created by inline
functions, where the argument list is templated.  This means that
whenever you call `GiNaC::sin(1)' it is equivalent to `sin(ex(1))' and
will therefore not result in a floating point number.  Unless of course
the function prototype is explicitly overridden - which is the case for
arguments of type `numeric' (not wrapped inside an `ex').  Hence, in
order to obtain a floating point number of class `numeric' you should
call `sin(numeric(1))'.  This is almost the same as calling
`sin(1).evalf()' except that the latter will return a numeric wrapped
inside an `ex'.


File: ginac.info,  Node: Relations,  Next: Integrals,  Prev: Mathematical functions,  Up: Basic concepts

Relations
=========

Sometimes, a relation holding between two expressions must be stored
somehow.  The class `relational' is a convenient container for such
purposes.  A relation is by definition a container for two `ex' and a
relation between them that signals equality, inequality and so on.
They are created by simply using the C++ operators `==', `!=', `<',
`<=', `>' and `>=' between two expressions.

*Note Mathematical functions::, for examples where various applications
of the `.subs()' method show how objects of class relational are used
as arguments.  There they provide an intuitive syntax for
substitutions.  They are also used as arguments to the `ex::series'
method, where the left hand side of the relation specifies the variable
to expand in and the right hand side the expansion point.  They can also
be used for creating systems of equations that are to be solved for
unknown variables.  But the most common usage of objects of this class
is rather inconspicuous in statements of the form `if
(expand(pow(a+b,2))==a*a+2*a*b+b*b) {...}'.  Here, an implicit
conversion from `relational' to `bool' takes place.  Note, however,
that `==' here does not perform any simplifications, hence `expand()'
must be called explicitly.


File: ginac.info,  Node: Integrals,  Next: Matrices,  Prev: Relations,  Up: Basic concepts

Integrals
=========

An object of class "integral" can be used to hold a symbolic integral.
If you want to symbolically represent the integral of `x*x' from 0 to
1, you would write this as
     integral(x, 0, 1, x*x)
The first argument is the integration variable. It should be noted that
GiNaC is not very good (yet?) at symbolically evaluating integrals. In
fact, it can only integrate polynomials. An expression containing
integrals can be evaluated symbolically by calling the
     .eval_integ()
method on it. Numerical evaluation is available by calling the
     .evalf()
method on an expression containing the integral. This will only evaluate
integrals into a number if `subs'ing the integration variable by a
number in the fourth argument of an integral and then `evalf'ing the
result always results in a number. Of course, also the boundaries of the
integration domain must `evalf' into numbers. It should be noted that
trying to `evalf' a function with discontinuities in the integration
domain is not recommended. The accuracy of the numeric evaluation of
integrals is determined by the static member variable
     ex integral::relative_integration_error
of the class `integral'. The default value of this is 10^-8.  The
integration works by halving the interval of integration, until numeric
stability of the answer indicates that the requested accuracy has been
reached. The maximum depth of the halving can be set via the static
member variable
     int integral::max_integration_level
The default value is 15. If this depth is exceeded, `evalf' will simply
return the integral unevaluated. The function that performs the
numerical evaluation, is also available as
     ex adaptivesimpson(const ex & x, const ex & a, const ex & b, const ex & f,
                        const ex & error)
This function will throw an exception if the maximum depth is exceeded.
The last parameter of the function is optional and defaults to the
`relative_integration_error'. To make sure that we do not do too much
work if an expression contains the same integral multiple times, a
lookup table is used.

If you know that an expression holds an integral, you can get the
integration variable, the left boundary, right boundary and integrand by
respectively calling `.op(0)', `.op(1)', `.op(2)', and `.op(3)'.
Differentiating integrals with respect to variables works as expected.
Note that it makes no sense to differentiate an integral with respect
to the integration variable.


File: ginac.info,  Node: Matrices,  Next: Indexed objects,  Prev: Integrals,  Up: Basic concepts

Matrices
========

A "matrix" is a two-dimensional array of expressions. The elements of a
matrix with m rows and n columns are accessed with two `unsigned'
indices, the first one in the range 0...m-1, the second one in the
range 0...n-1.

There are a couple of ways to construct matrices, with or without preset
elements. The constructor

     matrix::matrix(unsigned r, unsigned c);

creates a matrix with `r' rows and `c' columns with all elements set to
zero.

The fastest way to create a matrix with preinitialized elements is to
assign a list of comma-separated expressions to an empty matrix (see
below for an example). But you can also specify the elements as a
(flat) list with

     matrix::matrix(unsigned r, unsigned c, const lst & l);

The function

     ex lst_to_matrix(const lst & l);

constructs a matrix from a list of lists, each list representing a
matrix row.

There is also a set of functions for creating some special types of
matrices:

     ex diag_matrix(const lst & l);
     ex unit_matrix(unsigned x);
     ex unit_matrix(unsigned r, unsigned c);
     ex symbolic_matrix(unsigned r, unsigned c, const string & base_name);
     ex symbolic_matrix(unsigned r, unsigned c, const string & base_name,
                        const string & tex_base_name);

`diag_matrix()' constructs a diagonal matrix given the list of diagonal
elements. `unit_matrix()' creates an `x' by `x' (or `r' by `c') unit
matrix. And finally, `symbolic_matrix' constructs a matrix filled with
newly generated symbols made of the specified base name and the
position of each element in the matrix.

Matrices often arise by omitting elements of another matrix. For
instance, the submatrix `S' of a matrix `M' takes a rectangular block
from `M'. The reduced matrix `R' is defined by removing one row and one
column from a matrix `M'. (The determinant of a reduced matrix is
called a _Minor_ of `M' and can be used for computing the inverse using
Cramer's rule.)

     ex sub_matrix(const matrix&m, unsigned r, unsigned nr, unsigned c, unsigned nc);
     ex reduced_matrix(const matrix& m, unsigned r, unsigned c);

The function `sub_matrix()' takes a row offset `r' and a column offset
`c' and takes a block of `nr' rows and `nc' columns. The function
`reduced_matrix()' has two integer arguments that specify which row and
column to remove:

     {
         matrix m(3,3);
         m = 11, 12, 13,
             21, 22, 23,
             31, 32, 33;
         cout << reduced_matrix(m, 1, 1) << endl;
         // -> [[11,13],[31,33]]
         cout << sub_matrix(m, 1, 2, 1, 2) << endl;
         // -> [[22,23],[32,33]]
     }

Matrix elements can be accessed and set using the parenthesis (function
call) operator:

     const ex & matrix::operator()(unsigned r, unsigned c) const;
     ex & matrix::operator()(unsigned r, unsigned c);

It is also possible to access the matrix elements in a linear fashion
with the `op()' method. But C++-style subscripting with square brackets
`[]' is not available.

Here are a couple of examples for constructing matrices:

     {
         symbol a("a"), b("b");
     
         matrix M(2, 2);
         M = a, 0,
             0, b;
         cout << M << endl;
          // -> [[a,0],[0,b]]
     
         matrix M2(2, 2);
         M2(0, 0) = a;
         M2(1, 1) = b;
         cout << M2 << endl;
          // -> [[a,0],[0,b]]
     
         cout << matrix(2, 2, lst(a, 0, 0, b)) << endl;
          // -> [[a,0],[0,b]]
     
         cout << lst_to_matrix(lst(lst(a, 0), lst(0, b))) << endl;
          // -> [[a,0],[0,b]]
     
         cout << diag_matrix(lst(a, b)) << endl;
          // -> [[a,0],[0,b]]
     
         cout << unit_matrix(3) << endl;
          // -> [[1,0,0],[0,1,0],[0,0,1]]
     
         cout << symbolic_matrix(2, 3, "x") << endl;
          // -> [[x00,x01,x02],[x10,x11,x12]]
     }

The method `matrix::is_zero_matrix()' returns `true' only if all
entries of the matrix are zeros. There is also method
`ex::is_zero_matrix()' which returns `true' only if the expression is
zero or a zero matrix.

There are three ways to do arithmetic with matrices. The first (and most
direct one) is to use the methods provided by the `matrix' class:

     matrix matrix::add(const matrix & other) const;
     matrix matrix::sub(const matrix & other) const;
     matrix matrix::mul(const matrix & other) const;
     matrix matrix::mul_scalar(const ex & other) const;
     matrix matrix::pow(const ex & expn) const;
     matrix matrix::transpose() const;

All of these methods return the result as a new matrix object. Here is
an example that calculates A*B-2*C for three matrices A, B and C:

     {
         matrix A(2, 2), B(2, 2), C(2, 2);
         A =  1, 2,
              3, 4;
         B = -1, 0,
              2, 1;
         C =  8, 4,
              2, 1;
     
         matrix result = A.mul(B).sub(C.mul_scalar(2));
         cout << result << endl;
          // -> [[-13,-6],[1,2]]
         ...
     }

The second (and probably the most natural) way is to construct an
expression containing matrices with the usual arithmetic operators and
`pow()'.  For efficiency reasons, expressions with sums, products and
powers of matrices are not automatically evaluated in GiNaC. You have
to call the method

     ex ex::evalm() const;

to obtain the result:

     {
         ...
         ex e = A*B - 2*C;
         cout << e << endl;
          // -> [[1,2],[3,4]]*[[-1,0],[2,1]]-2*[[8,4],[2,1]]
         cout << e.evalm() << endl;
          // -> [[-13,-6],[1,2]]
         ...
     }

The non-commutativity of the product `A*B' in this example is
automatically recognized by GiNaC. There is no need to use a special
operator here. *Note Non-commutative objects::, for more information
about dealing with non-commutative expressions.

Finally, you can work with indexed matrices and call
`simplify_indexed()' to perform the arithmetic:

     {
         ...
         idx i(symbol("i"), 2), j(symbol("j"), 2), k(symbol("k"), 2);
         e = indexed(A, i, k) * indexed(B, k, j) - 2 * indexed(C, i, j);
         cout << e << endl;
          // -> -2*[[8,4],[2,1]].i.j+[[-1,0],[2,1]].k.j*[[1,2],[3,4]].i.k
         cout << e.simplify_indexed() << endl;
          // -> [[-13,-6],[1,2]].i.j
     }

Using indices is most useful when working with rectangular matrices and
one-dimensional vectors because you don't have to worry about having to
transpose matrices before multiplying them. *Note Indexed objects::, for
more information about using matrices with indices, and about indices in
general.

The `matrix' class provides a couple of additional methods for
computing determinants, traces, characteristic polynomials and ranks:

     ex matrix::determinant(unsigned algo=determinant_algo::automatic) const;
     ex matrix::trace() const;
     ex matrix::charpoly(const ex & lambda) const;
     unsigned matrix::rank() const;

The `algo' argument of `determinant()' allows to select between
different algorithms for calculating the determinant.  The asymptotic
speed (as parametrized by the matrix size) can greatly differ between
those algorithms, depending on the nature of the matrix' entries.  The
possible values are defined in the `flags.h' header file.  By default,
GiNaC uses a heuristic to automatically select an algorithm that is
likely (but not guaranteed) to give the result most quickly.

Matrices may also be inverted using the `ex matrix::inverse()' method
and linear systems may be solved with:

     matrix matrix::solve(const matrix & vars, const matrix & rhs,
                          unsigned algo=solve_algo::automatic) const;

Assuming the matrix object this method is applied on is an `m' times
`n' matrix, then `vars' must be a `n' times `p' matrix of symbolic
indeterminates and `rhs' a `m' times `p' matrix.  The returned matrix
then has dimension `n' times `p' and in the case of an underdetermined
system will still contain some of the indeterminates from `vars'.  If
the system is overdetermined, an exception is thrown.


File: ginac.info,  Node: Indexed objects,  Next: Non-commutative objects,  Prev: Matrices,  Up: Basic concepts

Indexed objects
===============

GiNaC allows you to handle expressions containing general indexed
objects in arbitrary spaces. It is also able to canonicalize and
simplify such expressions and perform symbolic dummy index summations.
There are a number of predefined indexed objects provided, like delta
and metric tensors.

There are few restrictions placed on indexed objects and their indices
and it is easy to construct nonsense expressions, but our intention is
to provide a general framework that allows you to implement algorithms
with indexed quantities, getting in the way as little as possible.

Indexed quantities and their indices
------------------------------------

Indexed expressions in GiNaC are constructed of two special types of
objects, "index objects" and "indexed objects".

   * Index objects are of class `idx' or a subclass. Every index has a
     "value" and a "dimension" (which is the dimension of the space the
     index lives in) which can both be arbitrary expressions but are
     usually a number or a simple symbol. In addition, indices of class
     `varidx' have a "variance" (they can be co- or contravariant), and
     indices of class `spinidx' have a variance and can be "dotted" or
     "undotted".

   * Indexed objects are of class `indexed' or a subclass. They contain
     a "base expression" (which is the expression being indexed), and
     one or more indices.


*Please notice:* when printing expressions, covariant indices and
indices without variance are denoted `.i' while contravariant indices
are denoted `~i'. Dotted indices have a `*' in front of the index
value. In the following, we are going to use that notation in the text
so instead of A^i_jk we will write `A~i.j.k'. Index dimensions are not
visible in the output.

A simple example shall illustrate the concepts:

     #include <iostream>
     #include <ginac/ginac.h>
     using namespace std;
     using namespace GiNaC;
     
     int main()
     {
         symbol i_sym("i"), j_sym("j");
         idx i(i_sym, 3), j(j_sym, 3);
     
         symbol A("A");
         cout << indexed(A, i, j) << endl;
          // -> A.i.j
         cout << index_dimensions << indexed(A, i, j) << endl;
          // -> A.i[3].j[3]
         cout << dflt; // reset cout to default output format (dimensions hidden)
         ...

The `idx' constructor takes two arguments, the index value and the
index dimension. First we define two index objects, `i' and `j', both
with the numeric dimension 3. The value of the index `i' is the symbol
`i_sym' (which prints as `i') and the value of the index `j' is the
symbol `j_sym' (which prints as `j'). Next we construct an expression
containing one indexed object, `A.i.j'. It has the symbol `A' as its
base expression and the two indices `i' and `j'.

The dimensions of indices are normally not visible in the output, but
one can request them to be printed with the `index_dimensions'
manipulator, as shown above.

Note the difference between the indices `i' and `j' which are of class
`idx', and the index values which are the symbols `i_sym' and `j_sym'.
The indices of indexed objects cannot directly be symbols or numbers
but must be index objects. For example, the following is not correct
and will raise an exception:

     symbol i("i"), j("j");
     e = indexed(A, i, j); // ERROR: indices must be of type idx

You can have multiple indexed objects in an expression, index values can
be numeric, and index dimensions symbolic:

         ...
         symbol B("B"), dim("dim");
         cout << 4 * indexed(A, i)
               + indexed(B, idx(j_sym, 4), idx(2, 3), idx(i_sym, dim)) << endl;
          // -> B.j.2.i+4*A.i
         ...

`B' has a 4-dimensional symbolic index `k', a 3-dimensional numeric
index of value 2, and a symbolic index `i' with the symbolic dimension
`dim'. Note that GiNaC doesn't automatically notify you that the free
indices of `A' and `B' in the sum don't match (you have to call
`simplify_indexed()' for that, see below).

In fact, base expressions, index values and index dimensions can be
arbitrary expressions:

         ...
         cout << indexed(A+B, idx(2*i_sym+1, dim/2)) << endl;
          // -> (B+A).(1+2*i)
         ...

It's also possible to construct nonsense like `Pi.sin(x)'. You will not
get an error message from this but you will probably not be able to do
anything useful with it.

The methods

     ex idx::get_value();
     ex idx::get_dimension();

return the value and dimension of an `idx' object. If you have an index
in an expression, such as returned by calling `.op()' on an indexed
object, you can get a reference to the `idx' object with the function
`ex_to<idx>()' on the expression.

There are also the methods

     bool idx::is_numeric();
     bool idx::is_symbolic();
     bool idx::is_dim_numeric();
     bool idx::is_dim_symbolic();

for checking whether the value and dimension are numeric or symbolic
(non-numeric). Using the `info()' method of an index (see *Note
Information about expressions::) returns information about the index
value.

If you need co- and contravariant indices, use the `varidx' class:

         ...
         symbol mu_sym("mu"), nu_sym("nu");
         varidx mu(mu_sym, 4), nu(nu_sym, 4); // default is contravariant ~mu, ~nu
         varidx mu_co(mu_sym, 4, true);       // covariant index .mu
     
         cout << indexed(A, mu, nu) << endl;
          // -> A~mu~nu
         cout << indexed(A, mu_co, nu) << endl;
          // -> A.mu~nu
         cout << indexed(A, mu.toggle_variance(), nu) << endl;
          // -> A.mu~nu
         ...

A `varidx' is an `idx' with an additional flag that marks it as co- or
contravariant. The default is a contravariant (upper) index, but this
can be overridden by supplying a third argument to the `varidx'
constructor. The two methods

     bool varidx::is_covariant();
     bool varidx::is_contravariant();

allow you to check the variance of a `varidx' object (use
`ex_to<varidx>()' to get the object reference from an expression).
There's also the very useful method

     ex varidx::toggle_variance();

which makes a new index with the same value and dimension but the
opposite variance. By using it you only have to define the index once.

The `spinidx' class provides dotted and undotted variant indices, as
used in the Weyl-van-der-Waerden spinor formalism:

         ...
         symbol K("K"), C_sym("C"), D_sym("D");
         spinidx C(C_sym, 2), D(D_sym);          // default is 2-dimensional,
                                                 // contravariant, undotted
         spinidx C_co(C_sym, 2, true);           // covariant index
         spinidx D_dot(D_sym, 2, false, true);   // contravariant, dotted
         spinidx D_co_dot(D_sym, 2, true, true); // covariant, dotted
     
         cout << indexed(K, C, D) << endl;
          // -> K~C~D
         cout << indexed(K, C_co, D_dot) << endl;
          // -> K.C~*D
         cout << indexed(K, D_co_dot, D) << endl;
          // -> K.*D~D
         ...

A `spinidx' is a `varidx' with an additional flag that marks it as
dotted or undotted. The default is undotted but this can be overridden
by supplying a fourth argument to the `spinidx' constructor. The two
methods

     bool spinidx::is_dotted();
     bool spinidx::is_undotted();

allow you to check whether or not a `spinidx' object is dotted (use
`ex_to<spinidx>()' to get the object reference from an expression).
Finally, the two methods

     ex spinidx::toggle_dot();
     ex spinidx::toggle_variance_dot();

create a new index with the same value and dimension but opposite
dottedness and the same or opposite variance.

Substituting indices
--------------------

Sometimes you will want to substitute one symbolic index with another
symbolic or numeric index, for example when calculating one specific
element of a tensor expression. This is done with the `.subs()' method,
as it is done for symbols (see *Note Substituting expressions::).

You have two possibilities here. You can either substitute the whole
index by another index or expression:

         ...
         ex e = indexed(A, mu_co);
         cout << e << " becomes " << e.subs(mu_co == nu) << endl;
          // -> A.mu becomes A~nu
         cout << e << " becomes " << e.subs(mu_co == varidx(0, 4)) << endl;
          // -> A.mu becomes A~0
         cout << e << " becomes " << e.subs(mu_co == 0) << endl;
          // -> A.mu becomes A.0
         ...

The third example shows that trying to replace an index with something
that is not an index will substitute the index value instead.

Alternatively, you can substitute the _symbol_ of a symbolic index by
another expression:

         ...
         ex e = indexed(A, mu_co);
         cout << e << " becomes " << e.subs(mu_sym == nu_sym) << endl;
          // -> A.mu becomes A.nu
         cout << e << " becomes " << e.subs(mu_sym == 0) << endl;
          // -> A.mu becomes A.0
         ...

As you see, with the second method only the value of the index will get
substituted. Its other properties, including its dimension, remain
unchanged.  If you want to change the dimension of an index you have to
substitute the whole index by another one with the new dimension.

Finally, substituting the base expression of an indexed object works as
expected:

         ...
         ex e = indexed(A, mu_co);
         cout << e << " becomes " << e.subs(A == A+B) << endl;
          // -> A.mu becomes (B+A).mu
         ...

Symmetries
----------

Indexed objects can have certain symmetry properties with respect to
their indices. Symmetries are specified as a tree of objects of class
`symmetry' that is constructed with the helper functions

     symmetry sy_none(...);
     symmetry sy_symm(...);
     symmetry sy_anti(...);
     symmetry sy_cycl(...);

`sy_none()' stands for no symmetry, `sy_symm()' and `sy_anti()' specify
fully symmetric or antisymmetric, respectively, and `sy_cycl()'
represents a cyclic symmetry. Each of these functions accepts up to four
arguments which can be either symmetry objects themselves or unsigned
integer numbers that represent an index position (counting from 0). A
symmetry specification that consists of only a single `sy_symm()',
`sy_anti()' or `sy_cycl()' with no arguments specifies the respective
symmetry for all indices.

Here are some examples of symmetry definitions:

         ...
         // No symmetry:
         e = indexed(A, i, j);
         e = indexed(A, sy_none(), i, j);     // equivalent
         e = indexed(A, sy_none(0, 1), i, j); // equivalent
     
         // Symmetric in all three indices:
         e = indexed(A, sy_symm(), i, j, k);
         e = indexed(A, sy_symm(0, 1, 2), i, j, k); // equivalent
         e = indexed(A, sy_symm(2, 0, 1), i, j, k); // same symmetry, but yields a
                                                    // different canonical order
     
         // Symmetric in the first two indices only:
         e = indexed(A, sy_symm(0, 1), i, j, k);
         e = indexed(A, sy_none(sy_symm(0, 1), 2), i, j, k); // equivalent
     
         // Antisymmetric in the first and last index only (index ranges need not
         // be contiguous):
         e = indexed(A, sy_anti(0, 2), i, j, k);
         e = indexed(A, sy_none(sy_anti(0, 2), 1), i, j, k); // equivalent
     
         // An example of a mixed symmetry: antisymmetric in the first two and
         // last two indices, symmetric when swapping the first and last index
         // pairs (like the Riemann curvature tensor):
         e = indexed(A, sy_symm(sy_anti(0, 1), sy_anti(2, 3)), i, j, k, l);
     
         // Cyclic symmetry in all three indices:
         e = indexed(A, sy_cycl(), i, j, k);
         e = indexed(A, sy_cycl(0, 1, 2), i, j, k); // equivalent
     
         // The following examples are invalid constructions that will throw
         // an exception at run time.
     
         // An index may not appear multiple times:
         e = indexed(A, sy_symm(0, 0, 1), i, j, k); // ERROR
         e = indexed(A, sy_none(sy_symm(0, 1), sy_anti(0, 2)), i, j, k); // ERROR
     
         // Every child of sy_symm(), sy_anti() and sy_cycl() must refer to the
         // same number of indices:
         e = indexed(A, sy_symm(sy_anti(0, 1), 2), i, j, k); // ERROR
     
         // And of course, you cannot specify indices which are not there:
         e = indexed(A, sy_symm(0, 1, 2, 3), i, j, k); // ERROR
         ...

If you need to specify more than four indices, you have to use the
`.add()' method of the `symmetry' class. For example, to specify full
symmetry in the first six indices you would write `sy_symm(0, 1, 2,
3).add(4).add(5)'.

If an indexed object has a symmetry, GiNaC will automatically bring the
indices into a canonical order which allows for some immediate
simplifications:

         ...
         cout << indexed(A, sy_symm(), i, j)
               + indexed(A, sy_symm(), j, i) << endl;
          // -> 2*A.j.i
         cout << indexed(B, sy_anti(), i, j)
               + indexed(B, sy_anti(), j, i) << endl;
          // -> 0
         cout << indexed(B, sy_anti(), i, j, k)
               - indexed(B, sy_anti(), j, k, i) << endl;
          // -> 0
         ...

Dummy indices
-------------

GiNaC treats certain symbolic index pairs as "dummy indices" meaning
that a summation over the index range is implied. Symbolic indices
which are not dummy indices are called "free indices". Numeric indices
are neither dummy nor free indices.

To be recognized as a dummy index pair, the two indices must be of the
same class and their value must be the same single symbol (an index like
`2*n+1' is never a dummy index). If the indices are of class `varidx'
they must also be of opposite variance; if they are of class `spinidx'
they must be both dotted or both undotted.

The method `.get_free_indices()' returns a vector containing the free
indices of an expression. It also checks that the free indices of the
terms of a sum are consistent:

     {
         symbol A("A"), B("B"), C("C");
     
         symbol i_sym("i"), j_sym("j"), k_sym("k"), l_sym("l");
         idx i(i_sym, 3), j(j_sym, 3), k(k_sym, 3), l(l_sym, 3);
     
         ex e = indexed(A, i, j) * indexed(B, j, k) + indexed(C, k, l, i, l);
         cout << exprseq(e.get_free_indices()) << endl;
          // -> (.i,.k)
          // 'j' and 'l' are dummy indices
     
         symbol mu_sym("mu"), nu_sym("nu"), rho_sym("rho"), sigma_sym("sigma");
         varidx mu(mu_sym, 4), nu(nu_sym, 4), rho(rho_sym, 4), sigma(sigma_sym, 4);
     
         e = indexed(A, mu, nu) * indexed(B, nu.toggle_variance(), rho)
           + indexed(C, mu, sigma, rho, sigma.toggle_variance());
         cout << exprseq(e.get_free_indices()) << endl;
          // -> (~mu,~rho)
          // 'nu' is a dummy index, but 'sigma' is not
     
         e = indexed(A, mu, mu);
         cout << exprseq(e.get_free_indices()) << endl;
          // -> (~mu)
          // 'mu' is not a dummy index because it appears twice with the same
          // variance
     
         e = indexed(A, mu, nu) + 42;
         cout << exprseq(e.get_free_indices()) << endl; // ERROR
          // this will throw an exception:
          // "add::get_free_indices: inconsistent indices in sum"
     }

A dummy index summation like a.i b~i can be expanded for indices with
numeric dimensions (e.g. 3)  into the explicit sum like a.1 b~1 + a.2
b~2 + a.3 b~3.  This is performed by the function

         ex expand_dummy_sum(const ex & e, bool subs_idx = false);

which takes an expression `e' and returns the expanded sum for all
dummy indices with numeric dimensions. If the parameter `subs_idx' is
set to `true' then all substitutions are made by `idx' class indices,
i.e. without variance. In this case the above sum a.i b~i will be
expanded to a.1 b.1 + a.2 b.2 + a.3 b.3.

Simplifying indexed expressions
-------------------------------

In addition to the few automatic simplifications that GiNaC performs on
indexed expressions (such as re-ordering the indices of symmetric
tensors and calculating traces and convolutions of matrices and
predefined tensors) there is the method

     ex ex::simplify_indexed();
     ex ex::simplify_indexed(const scalar_products & sp);

that performs some more expensive operations:

   * it checks the consistency of free indices in sums in the same way
     `get_free_indices()' does

   * it tries to give dummy indices that appear in different terms of a
     sum   the same name to allow simplifications like a_i*b_i-a_j*b_j=0

   * it (symbolically) calculates all possible dummy index
     summations/contractions   with the predefined tensors (this will
     be explained in more detail in the   next section)

   * it detects contractions that vanish for symmetry reasons, for
     example   the contraction of a symmetric and a totally
     antisymmetric tensor

   * as a special case of dummy index summation, it can replace scalar
     products   of two tensors with a user-defined value

The last point is done with the help of the `scalar_products' class
which is used to store scalar products with known values (this is not an
arithmetic class, you just pass it to `simplify_indexed()'):

     {
         symbol A("A"), B("B"), C("C"), i_sym("i");
         idx i(i_sym, 3);
     
         scalar_products sp;
         sp.add(A, B, 0); // A and B are orthogonal
         sp.add(A, C, 0); // A and C are orthogonal
         sp.add(A, A, 4); // A^2 = 4 (A has length 2)
     
         e = indexed(A + B, i) * indexed(A + C, i);
         cout << e << endl;
          // -> (B+A).i*(A+C).i
     
         cout << e.expand(expand_options::expand_indexed).simplify_indexed(sp)
              << endl;
          // -> 4+C.i*B.i
     }

The `scalar_products' object `sp' acts as a storage for the scalar
products added to it with the `.add()' method. This method takes three
arguments: the two expressions of which the scalar product is taken,
and the expression to replace it with.

The example above also illustrates a feature of the `expand()' method:
if passed the `expand_indexed' option it will distribute indices over
sums, so `(A+B).i' becomes `A.i+B.i'.

Predefined tensors
------------------

Some frequently used special tensors such as the delta, epsilon and
metric tensors are predefined in GiNaC. They have special properties
when contracted with other tensor expressions and some of them have
constant matrix representations (they will evaluate to a number when
numeric indices are specified).

Delta tensor
............

The delta tensor takes two indices, is symmetric and has the matrix
representation `diag(1, 1, 1, ...)'. It is constructed by the function
`delta_tensor()':

     {
         symbol A("A"), B("B");
     
         idx i(symbol("i"), 3), j(symbol("j"), 3),
             k(symbol("k"), 3), l(symbol("l"), 3);
     
         ex e = indexed(A, i, j) * indexed(B, k, l)
              * delta_tensor(i, k) * delta_tensor(j, l);
         cout << e.simplify_indexed() << endl;
          // -> B.i.j*A.i.j
     
         cout << delta_tensor(i, i) << endl;
          // -> 3
     }

General metric tensor
.....................

The function `metric_tensor()' creates a general symmetric metric
tensor with two indices that can be used to raise/lower tensor indices.
The metric tensor is denoted as `g' in the output and if its indices
are of mixed variance it is automatically replaced by a delta tensor:

     {
         symbol A("A");
     
         varidx mu(symbol("mu"), 4), nu(symbol("nu"), 4), rho(symbol("rho"), 4);
     
         ex e = metric_tensor(mu, nu) * indexed(A, nu.toggle_variance(), rho);
         cout << e.simplify_indexed() << endl;
          // -> A~mu~rho
     
         e = delta_tensor(mu, nu.toggle_variance()) * metric_tensor(nu, rho);
         cout << e.simplify_indexed() << endl;
          // -> g~mu~rho
     
         e = metric_tensor(mu.toggle_variance(), nu.toggle_variance())
           * metric_tensor(nu, rho);
         cout << e.simplify_indexed() << endl;
          // -> delta.mu~rho
     
         e = metric_tensor(nu.toggle_variance(), rho.toggle_variance())
           * metric_tensor(mu, nu) * (delta_tensor(mu.toggle_variance(), rho)
             + indexed(A, mu.toggle_variance(), rho));
         cout << e.simplify_indexed() << endl;
          // -> 4+A.rho~rho
     }

Minkowski metric tensor
.......................

The Minkowski metric tensor is a special metric tensor with a constant
matrix representation which is either `diag(1, -1, -1, ...)' (negative
signature, the default) or `diag(-1, 1, 1, ...)' (positive signature).
It is created with the function `lorentz_g()' (although it is output as
`eta'):

     {
         varidx mu(symbol("mu"), 4);
     
         e = delta_tensor(varidx(0, 4), mu.toggle_variance())
           * lorentz_g(mu, varidx(0, 4));       // negative signature
         cout << e.simplify_indexed() << endl;
          // -> 1
     
         e = delta_tensor(varidx(0, 4), mu.toggle_variance())
           * lorentz_g(mu, varidx(0, 4), true); // positive signature
         cout << e.simplify_indexed() << endl;
          // -> -1
     }

Spinor metric tensor
....................

The function `spinor_metric()' creates an antisymmetric tensor with two
indices that is used to raise/lower indices of 2-component spinors.  It
is output as `eps':

     {
         symbol psi("psi");
     
         spinidx A(symbol("A")), B(symbol("B")), C(symbol("C"));
         ex A_co = A.toggle_variance(), B_co = B.toggle_variance();
     
         e = spinor_metric(A, B) * indexed(psi, B_co);
         cout << e.simplify_indexed() << endl;
          // -> psi~A
     
         e = spinor_metric(A, B) * indexed(psi, A_co);
         cout << e.simplify_indexed() << endl;
          // -> -psi~B
     
         e = spinor_metric(A_co, B_co) * indexed(psi, B);
         cout << e.simplify_indexed() << endl;
          // -> -psi.A
     
         e = spinor_metric(A_co, B_co) * indexed(psi, A);
         cout << e.simplify_indexed() << endl;
          // -> psi.B
     
         e = spinor_metric(A_co, B_co) * spinor_metric(A, B);
         cout << e.simplify_indexed() << endl;
          // -> 2
     
         e = spinor_metric(A_co, B_co) * spinor_metric(B, C);
         cout << e.simplify_indexed() << endl;
          // -> -delta.A~C
     }

The matrix representation of the spinor metric is `[[0, 1], [-1, 0]]'.

Epsilon tensor
..............

The epsilon tensor is totally antisymmetric, its number of indices is
equal to the dimension of the index space (the indices must all be of
the same numeric dimension), and `eps.1.2.3...' (resp. `eps~0~1~2...')
is defined to be 1. Its behavior with indices that have a variance also
depends on the signature of the metric. Epsilon tensors are output as
`eps'.

There are three functions defined to create epsilon tensors in 2, 3 and
4 dimensions:

     ex epsilon_tensor(const ex & i1, const ex & i2);
     ex epsilon_tensor(const ex & i1, const ex & i2, const ex & i3);
     ex lorentz_eps(const ex & i1, const ex & i2, const ex & i3, const ex & i4,
                    bool pos_sig = false);

The first two functions create an epsilon tensor in 2 or 3 Euclidean
dimensions, the last function creates an epsilon tensor in a
4-dimensional Minkowski space (the last `bool' argument specifies
whether the metric has negative or positive signature, as in the case
of the Minkowski metric tensor):

     {
         varidx mu(symbol("mu"), 4), nu(symbol("nu"), 4), rho(symbol("rho"), 4),
                sig(symbol("sig"), 4), lam(symbol("lam"), 4), bet(symbol("bet"), 4);
         e = lorentz_eps(mu, nu, rho, sig) *
             lorentz_eps(mu.toggle_variance(), nu.toggle_variance(), lam, bet);
         cout << simplify_indexed(e) << endl;
          // -> 2*eta~bet~rho*eta~sig~lam-2*eta~sig~bet*eta~rho~lam
     
         idx i(symbol("i"), 3), j(symbol("j"), 3), k(symbol("k"), 3);
         symbol A("A"), B("B");
         e = epsilon_tensor(i, j, k) * indexed(A, j) * indexed(B, k);
         cout << simplify_indexed(e) << endl;
          // -> -B.k*A.j*eps.i.k.j
         e = epsilon_tensor(i, j, k) * indexed(A, j) * indexed(A, k);
         cout << simplify_indexed(e) << endl;
          // -> 0
     }

Linear algebra
--------------

The `matrix' class can be used with indices to do some simple linear
algebra (linear combinations and products of vectors and matrices,
traces and scalar products):

     {
         idx i(symbol("i"), 2), j(symbol("j"), 2);
         symbol x("x"), y("y");
     
         // A is a 2x2 matrix, X is a 2x1 vector
         matrix A(2, 2), X(2, 1);
         A = 1, 2,
             3, 4;
         X = x, y;
     
         cout << indexed(A, i, i) << endl;
          // -> 5
     
         ex e = indexed(A, i, j) * indexed(X, j);
         cout << e.simplify_indexed() << endl;
          // -> [[2*y+x],[4*y+3*x]].i
     
         e = indexed(A, i, j) * indexed(X, i) + indexed(X, j) * 2;
         cout << e.simplify_indexed() << endl;
          // -> [[3*y+3*x,6*y+2*x]].j
     }

You can of course obtain the same results with the `matrix::add()',
`matrix::mul()' and `matrix::trace()' methods (*note Matrices::) but
with indices you don't have to worry about transposing matrices.

Matrix indices always start at 0 and their dimension must match the
number of rows/columns of the matrix. Matrices with one row or one
column are vectors and can have one or two indices (it doesn't matter
whether it's a row or a column vector). Other matrices must have two
indices.

You should be careful when using indices with variance on matrices.
GiNaC doesn't look at the variance and doesn't know that `F~mu~nu' and
`F.mu.nu' are different matrices. In this case you should use only one
form for `F' and explicitly multiply it with a matrix representation of
the metric tensor.

