This is ginac.info, produced by makeinfo version 4.5 from
/user/jensv/ginac/ginac/doc/tutorial/ginac.texi.

INFO-DIR-SECTION Mathematics
START-INFO-DIR-ENTRY
* ginac: (ginac).                   C++ library for symbolic computation.
END-INFO-DIR-ENTRY

This is a tutorial that documents GiNaC 1.4.3, an open framework for
symbolic computation within the C++ programming language.

Copyright (C) 1999-2008 Johannes Gutenberg University Mainz, Germany

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.


File: ginac.info,  Node: Pattern matching and advanced substitutions,  Next: Applying a function on subexpressions,  Prev: Substituting expressions,  Up: Methods and functions

Pattern matching and advanced substitutions
===========================================

GiNaC allows the use of patterns for checking whether an expression is
of a certain form or contains subexpressions of a certain form, and for
substituting expressions in a more general way.

A "pattern" is an algebraic expression that optionally contains
wildcards.  A "wildcard" is a special kind of object (of class
`wildcard') that represents an arbitrary expression. Every wildcard has
a "label" which is an unsigned integer number to allow having multiple
different wildcards in a pattern. Wildcards are printed as `$label'
(this is also the way they are specified in `ginsh'). In C++ code,
wildcard objects are created with the call

     ex wild(unsigned label = 0);

which is simply a wrapper for the `wildcard()' constructor with a
shorter name.

Some examples for patterns:

*Constructed as*                     *Output as*
`wild()'                             `$0'
`pow(x,wild())'                      `x^$0'
`atan2(wild(1),wild(2))'             `atan2($1,$2)'
`indexed(A,idx(wild(),3))'           `A.$0'

Notes:

   * Wildcards behave like symbols and are subject to the same algebraic
      rules. E.g., `$0+2*$0' is automatically transformed to `3*$0'.

   * As shown in the last example, to use wildcards for indices you
     have to   use them as the value of an `idx' object. This is
     because indices must   always be of class `idx' (or a subclass).

   * Wildcards only represent expressions or subexpressions. It is not
     possible to use them as placeholders for other properties like
     index   dimension or variance, representation labels, symmetry of
     indexed objects   etc.

   * Because wildcards are commutative, it is not possible to use
     wildcards   as part of noncommutative products.

   * A pattern does not have to contain wildcards. `x' and `x+y'   are
     also valid patterns.

Matching expressions
--------------------

The most basic application of patterns is to check whether an expression
matches a given pattern. This is done by the function

     bool ex::match(const ex & pattern);
     bool ex::match(const ex & pattern, lst & repls);

This function returns `true' when the expression matches the pattern
and `false' if it doesn't. If used in the second form, the actual
subexpressions matched by the wildcards get returned in the `repls'
object as a list of relations of the form `wildcard == expression'.  If
`match()' returns false, the state of `repls' is undefined.  For
reproducible results, the list should be empty when passed to
`match()', but it is also possible to find similarities in multiple
expressions by passing in the result of a previous match.

The matching algorithm works as follows:

   * A single wildcard matches any expression. If one wildcard appears
     multiple times in a pattern, it must match the same expression in
     all   places (e.g. `$0' matches anything, and `$0*($0+1)' matches
     `x*(x+1)' but not `x*(y+1)').

   * If the expression is not of the same class as the pattern, the
     match   fails (i.e. a sum only matches a sum, a function only
     matches a function,   etc.).

   * If the pattern is a function, it only matches the same function
     (i.e. `sin($0)' matches `sin(x)' but doesn't match `exp(x)').

   * Except for sums and products, the match fails if the number of
     subexpressions (`nops()') is not equal to the number of
     subexpressions   of the pattern.

   * If there are no subexpressions, the expressions and the pattern
     must   be equal (in the sense of `is_equal()').

   * Except for sums and products, each subexpression (`op()') must
     match the corresponding subexpression of the pattern.

Sums (`add') and products (`mul') are treated in a special way to
account for their commutativity and associativity:

   * If the pattern contains a term or factor that is a single wildcard,
      this one is used as the "global wildcard". If there is more than
     one   such wildcard, one of them is chosen as the global wildcard
     in a random   way.

   * Every term/factor of the pattern, except the global wildcard, is
     matched against every term of the expression in sequence. If no
     match is   found, the whole match fails. Terms that did match are
     not considered in   further matches.

   * If there are no unmatched terms left, the match succeeds. Otherwise
      the match fails unless there is a global wildcard in the
     pattern, in   which case this wildcard matches the remaining terms.

In general, having more than one single wildcard as a term of a sum or a
factor of a product (such as `a+$0+$1') will lead to unpredictable or
ambiguous results.

Here are some examples in `ginsh' to demonstrate how it works (the
`match()' function in `ginsh' returns `FAIL' if the match fails, and
the list of wildcard replacements otherwise):

     > match((x+y)^a,(x+y)^a);
     {}
     > match((x+y)^a,(x+y)^b);
     FAIL
     > match((x+y)^a,$1^$2);
     {$1==x+y,$2==a}
     > match((x+y)^a,$1^$1);
     FAIL
     > match((x+y)^(x+y),$1^$1);
     {$1==x+y}
     > match((x+y)^(x+y),$1^$2);
     {$1==x+y,$2==x+y}
     > match((a+b)*(a+c),($1+b)*($1+c));
     {$1==a}
     > match((a+b)*(a+c),(a+$1)*(a+$2));
     {$1==b,$2==c}
       (Unpredictable. The result might also be [$1==c,$2==b].)
     > match((a+b)*(a+c),($1+$2)*($1+$3));
       (The result is undefined. Due to the sequential nature of the algorithm
        and the re-ordering of terms in GiNaC, the match for the first factor
        may be {$1==a,$2==b} in which case the match for the second factor
        succeeds, or it may be {$1==b,$2==a} which causes the second match to
        fail.)
     > match(a*(x+y)+a*z+b,a*$1+$2);
       (This is also ambiguous and may return either {$1==z,$2==a*(x+y)+b} or
        {$1=x+y,$2=a*z+b}.)
     > match(a+b+c+d+e+f,c);
     FAIL
     > match(a+b+c+d+e+f,c+$0);
     {$0==a+e+b+f+d}
     > match(a+b+c+d+e+f,c+e+$0);
     {$0==a+b+f+d}
     > match(a+b,a+b+$0);
     {$0==0}
     > match(a*b^2,a^$1*b^$2);
     FAIL
       (The matching is syntactic, not algebraic, and "a" doesn't match "a^$1"
        even though a==a^1.)
     > match(x*atan2(x,x^2),$0*atan2($0,$0^2));
     {$0==x}
     > match(atan2(y,x^2),atan2(y,$0));
     {$0==x^2}

Matching parts of expressions
-----------------------------

A more general way to look for patterns in expressions is provided by
the member function

     bool ex::has(const ex & pattern);

This function checks whether a pattern is matched by an expression
itself or by any of its subexpressions.

Again some examples in `ginsh' for illustration (in `ginsh', `has()'
returns `1' for `true' and `0' for `false'):

     > has(x*sin(x+y+2*a),y);
     1
     > has(x*sin(x+y+2*a),x+y);
     0
       (This is because in GiNaC, "x+y" is not a subexpression of "x+y+2*a" (which
        has the subexpressions "x", "y" and "2*a".)
     > has(x*sin(x+y+2*a),x+y+$1);
     1
       (But this is possible.)
     > has(x*sin(2*(x+y)+2*a),x+y);
     0
       (This fails because "2*(x+y)" automatically gets converted to "2*x+2*y" of
        which "x+y" is not a subexpression.)
     > has(x+1,x^$1);
     0
       (Although x^1==x and x^0==1, neither "x" nor "1" are actually of the form
        "x^something".)
     > has(4*x^2-x+3,$1*x);
     1
     > has(4*x^2+x+3,$1*x);
     0
       (Another possible pitfall. The first expression matches because the term
        "-x" has the form "(-1)*x" in GiNaC. To check whether a polynomial
        contains a linear term you should use the coeff() function instead.)

The method

     bool ex::find(const ex & pattern, lst & found);

works a bit like `has()' but it doesn't stop upon finding the first
match. Instead, it appends all found matches to the specified list. If
there are multiple occurrences of the same expression, it is entered
only once to the list. `find()' returns false if no matches were found
(in `ginsh', it returns an empty list):

     > find(1+x+x^2+x^3,x);
     {x}
     > find(1+x+x^2+x^3,y);
     {}
     > find(1+x+x^2+x^3,x^$1);
     {x^3,x^2}
       (Note the absence of "x".)
     > expand((sin(x)+sin(y))*(a+b));
     sin(y)*a+sin(x)*b+sin(x)*a+sin(y)*b
     > find(%,sin($1));
     {sin(y),sin(x)}

Substituting expressions
------------------------

Probably the most useful application of patterns is to use them for
substituting expressions with the `subs()' method. Wildcards can be
used in the search patterns as well as in the replacement expressions,
where they get replaced by the expressions matched by them. `subs()'
doesn't know anything about algebra; it performs purely syntactic
substitutions.

Some examples:

     > subs(a^2+b^2+(x+y)^2,$1^2==$1^3);
     b^3+a^3+(x+y)^3
     > subs(a^4+b^4+(x+y)^4,$1^2==$1^3);
     b^4+a^4+(x+y)^4
     > subs((a+b+c)^2,a+b==x);
     (a+b+c)^2
     > subs((a+b+c)^2,a+b+$1==x+$1);
     (x+c)^2
     > subs(a+2*b,a+b==x);
     a+2*b
     > subs(4*x^3-2*x^2+5*x-1,x==a);
     -1+5*a-2*a^2+4*a^3
     > subs(4*x^3-2*x^2+5*x-1,x^$0==a^$0);
     -1+5*x-2*a^2+4*a^3
     > subs(sin(1+sin(x)),sin($1)==cos($1));
     cos(1+cos(x))
     > expand(subs(a*sin(x+y)^2+a*cos(x+y)^2+b,cos($1)^2==1-sin($1)^2));
     a+b

The last example would be written in C++ in this way:

     {
         symbol a("a"), b("b"), x("x"), y("y");
         e = a*pow(sin(x+y), 2) + a*pow(cos(x+y), 2) + b;
         e = e.subs(pow(cos(wild()), 2) == 1-pow(sin(wild()), 2));
         cout << e.expand() << endl;
          // -> a+b
     }

The option algebraic
--------------------

Both `has()' and `subs()' take an optional argument to pass them extra
options. This section describes what happens if you give the former the
option `has_options::algebraic' or the latter
`subs_options::algebraic'. In that case the matching condition for
powers and multiplications is changed in such a way that they become
more intuitive. Intuition says that `x*y' is a part of `x*y*z'.  If you
use these options you will find that `(x*y*z).has(x*y,
has_options::algebraic)' indeed returns true.  Besides matching some of
the factors of a product also powers match as often as is possible
without getting negative exponents. For example
`(x^5*y^2*z).subs(x^2*y^2==c, subs_options::algebraic)' will return
`x*c^2*z'. This also works with negative powers:
`(x^(-3)*y^(-2)*z).subs(1/(x*y)==c, subs_options::algebraic)' will
return `x^(-1)*c^2*z'.

*Note:* this only works for multiplications and not for locating `x+y'
within `x+y+z'.


File: ginac.info,  Node: Applying a function on subexpressions,  Next: Visitors and tree traversal,  Prev: Pattern matching and advanced substitutions,  Up: Methods and functions

Applying a function on subexpressions
=====================================

Sometimes you may want to perform an operation on specific parts of an
expression while leaving the general structure of it intact. An example
of this would be a matrix trace operation: the trace of a sum is the sum
of the traces of the individual terms. That is, the trace should "map"
on the sum, by applying itself to each of the sum's operands. It is
possible to do this manually which usually results in code like this:

     ex calc_trace(ex e)
     {
         if (is_a<matrix>(e))
             return ex_to<matrix>(e).trace();
         else if (is_a<add>(e)) {
             ex sum = 0;
             for (size_t i=0; i<e.nops(); i++)
                 sum += calc_trace(e.op(i));
             return sum;
         } else if (is_a<mul>)(e)) {
             ...
         } else {
             ...
         }
     }

This is, however, slightly inefficient (if the sum is very large it can
take a long time to add the terms one-by-one), and its applicability is
limited to a rather small class of expressions. If `calc_trace()' is
called with a relation or a list as its argument, you will probably
want the trace to be taken on both sides of the relation or of all
elements of the list.

GiNaC offers the `map()' method to aid in the implementation of such
operations:

     ex ex::map(map_function & f) const;
     ex ex::map(ex (*f)(const ex & e)) const;

In the first (preferred) form, `map()' takes a function object that is
subclassed from the `map_function' class. In the second form, it takes
a pointer to a function that accepts and returns an expression.
`map()' constructs a new expression of the same type, applying the
specified function on all subexpressions (in the sense of `op()'),
non-recursively.

The use of a function object makes it possible to supply more arguments
to the function that is being mapped, or to keep local state
information.  The `map_function' class declares a virtual function call
operator that you can overload. Here is a sample implementation of
`calc_trace()' that uses `map()' in a recursive fashion:

     struct calc_trace : public map_function {
         ex operator()(const ex &e)
         {
             if (is_a<matrix>(e))
                 return ex_to<matrix>(e).trace();
             else if (is_a<mul>(e)) {
                 ...
             } else
                 return e.map(*this);
         }
     };

This function object could then be used like this:

     {
         ex M = ... // expression with matrices
         calc_trace do_trace;
         ex tr = do_trace(M);
     }

Here is another example for you to meditate over.  It removes quadratic
terms in a variable from an expanded polynomial:

     struct map_rem_quad : public map_function {
         ex var;
         map_rem_quad(const ex & var_) : var(var_) {}
     
         ex operator()(const ex & e)
         {
             if (is_a<add>(e) || is_a<mul>(e))
          	    return e.map(*this);
             else if (is_a<power>(e) &&
                      e.op(0).is_equal(var) && e.op(1).info(info_flags::even))
                 return 0;
             else
                 return e;
         }
     };
     
     ...
     
     {
         symbol x("x"), y("y");
     
         ex e;
         for (int i=0; i<8; i++)
             e += pow(x, i) * pow(y, 8-i) * (i+1);
         cout << e << endl;
          // -> 4*y^5*x^3+5*y^4*x^4+8*y*x^7+7*y^2*x^6+2*y^7*x+6*y^3*x^5+3*y^6*x^2+y^8
     
         map_rem_quad rem_quad(x);
         cout << rem_quad(e) << endl;
          // -> 4*y^5*x^3+8*y*x^7+2*y^7*x+6*y^3*x^5+y^8
     }

`ginsh' offers a slightly different implementation of `map()' that
allows applying algebraic functions to operands. The second argument to
`map()' is an expression containing the wildcard `$0' which acts as the
placeholder for the operands:

     > map(a*b,sin($0));
     sin(a)*sin(b)
     > map(a+2*b,sin($0));
     sin(a)+sin(2*b)
     > map({a,b,c},$0^2+$0);
     {a^2+a,b^2+b,c^2+c}

Note that it is only possible to use algebraic functions in the second
argument. You can not use functions like `diff()', `op()', `subs()'
etc. because these are evaluated immediately:

     > map({a,b,c},diff($0,a));
     {0,0,0}
       This is because "diff($0,a)" evaluates to "0", so the command is equivalent
       to "map({a,b,c},0)".


File: ginac.info,  Node: Visitors and tree traversal,  Next: Polynomial arithmetic,  Prev: Applying a function on subexpressions,  Up: Methods and functions

Visitors and tree traversal
===========================

Suppose that you need a function that returns a list of all indices
appearing in an arbitrary expression. The indices can have any
dimension, and for indices with variance you always want the covariant
version returned.

You can't use `get_free_indices()' because you also want to include
dummy indices in the list, and you can't use `find()' as it needs
specific index dimensions (and it would require two passes: one for
indices with variance, one for plain ones).

The obvious solution to this problem is a tree traversal with a type
switch, such as the following:

     void gather_indices_helper(const ex & e, lst & l)
     {
         if (is_a<varidx>(e)) {
             const varidx & vi = ex_to<varidx>(e);
             l.append(vi.is_covariant() ? vi : vi.toggle_variance());
         } else if (is_a<idx>(e)) {
             l.append(e);
         } else {
             size_t n = e.nops();
             for (size_t i = 0; i < n; ++i)
                 gather_indices_helper(e.op(i), l);
         }
     }
     
     lst gather_indices(const ex & e)
     {
         lst l;
         gather_indices_helper(e, l);
         l.sort();
         l.unique();
         return l;
     }

This works fine but fans of object-oriented programming will feel
uncomfortable with the type switch. One reason is that there is a
possibility for subtle bugs regarding derived classes. If we had, for
example, written

         if (is_a<idx>(e)) {
           ...
         } else if (is_a<varidx>(e)) {
           ...

in `gather_indices_helper', the code wouldn't have worked because the
first line "absorbs" all classes derived from `idx', including
`varidx', so the special case for `varidx' would never have been
executed.

Also, for a large number of classes, a type switch like the above can
get unwieldy and inefficient (it's a linear search, after all).
`gather_indices_helper' only checks for two classes, but if you had to
write a function that required a different implementation for nearly
every GiNaC class, the result would be very hard to maintain and extend.

The cleanest approach to the problem would be to add a new virtual
function to GiNaC's class hierarchy. In our example, there would be
specializations for `idx' and `varidx' while the default implementation
in `basic' performed the tree traversal. Unfortunately, in C++ it's
impossible to add virtual member functions to existing classes without
changing their source and recompiling everything. GiNaC comes with
source, so you could actually do this, but for a small algorithm like
the one presented this would be impractical.

One solution to this dilemma is the "Visitor" design pattern, which is
implemented in GiNaC (actually, Robert Martin's Acyclic Visitor
variation, described in detail in
`http://objectmentor.com/publications/acv.pdf'). Instead of adding
virtual functions to the class hierarchy to implement operations, GiNaC
provides a single "bouncing" method `accept()' that takes an instance
of a special `visitor' class and redirects execution to the one
`visit()' virtual function of the visitor that matches the type of
object that `accept()' was being invoked on.

Visitors in GiNaC must derive from the global `visitor' class as well
as from the class `T::visitor' of each class `T' they want to visit,
and implement the member functions `void visit(const T &)' for each
class.

A call of

     void ex::accept(visitor & v) const;

will then dispatch to the correct `visit()' member function of the
specified visitor `v' for the type of GiNaC object at the root of the
expression tree (e.g. a `symbol', an `idx' or a `mul').

Here is an example of a visitor:

     class my_visitor
      : public visitor,          // this is required
        public add::visitor,     // visit add objects
        public numeric::visitor, // visit numeric objects
        public basic::visitor    // visit basic objects
     {
         void visit(const add & x)
         { cout << "called with an add object" << endl; }
     
         void visit(const numeric & x)
         { cout << "called with a numeric object" << endl; }
     
         void visit(const basic & x)
         { cout << "called with a basic object" << endl; }
     };

which can be used as follows:

     ...
         symbol x("x");
         ex e1 = 42;
         ex e2 = 4*x-3;
         ex e3 = 8*x;
     
         my_visitor v;
         e1.accept(v);
          // prints "called with a numeric object"
         e2.accept(v);
          // prints "called with an add object"
         e3.accept(v);
          // prints "called with a basic object"
     ...

The `visit(const basic &)' method gets called for all objects that are
not `numeric' or `add' and acts as an (optional) default.

From a conceptual point of view, the `visit()' methods of the visitor
behave like a newly added virtual function of the visited hierarchy.
In addition, visitors can store state in member variables, and they can
be extended by deriving a new visitor from an existing one, thus
building hierarchies of visitors.

We can now rewrite our index example from above with a visitor:

     class gather_indices_visitor
      : public visitor, public idx::visitor, public varidx::visitor
     {
         lst l;
     
         void visit(const idx & i)
         {
             l.append(i);
         }
     
         void visit(const varidx & vi)
         {
             l.append(vi.is_covariant() ? vi : vi.toggle_variance());
         }
     
     public:
         const lst & get_result() // utility function
         {
             l.sort();
             l.unique();
             return l;
         }
     };

What's missing is the tree traversal. We could implement it in
`visit(const basic &)', but GiNaC has predefined methods for this:

     void ex::traverse_preorder(visitor & v) const;
     void ex::traverse_postorder(visitor & v) const;
     void ex::traverse(visitor & v) const;

`traverse_preorder()' visits a node _before_ visiting its
subexpressions, while `traverse_postorder()' visits a node _after_
visiting its subexpressions. `traverse()' is a synonym for
`traverse_preorder()'.

Here is a new implementation of `gather_indices()' that uses the visitor
and `traverse()':

     lst gather_indices(const ex & e)
     {
         gather_indices_visitor v;
         e.traverse(v);
         return v.get_result();
     }

Alternatively, you could use pre- or postorder iterators for the tree
traversal:

     lst gather_indices(const ex & e)
     {
         gather_indices_visitor v;
         for (const_preorder_iterator i = e.preorder_begin();
              i != e.preorder_end(); ++i) {
             i->accept(v);
         }
         return v.get_result();
     }


File: ginac.info,  Node: Polynomial arithmetic,  Next: Rational expressions,  Prev: Visitors and tree traversal,  Up: Methods and functions

Polynomial arithmetic
=====================

Testing whether an expression is a polynomial
---------------------------------------------

Testing whether an expression is a polynomial in one or more variables
can be done with the method
     bool ex::is_polynomial(const ex & vars) const;
In the case of more than one variable, the variables are given as a
list.

     (x*y*sin(y)).is_polynomial(x)         // Returns true.
     (x*y*sin(y)).is_polynomial(lst(x,y))  // Returns false.

Expanding and collecting
------------------------

A polynomial in one or more variables has many equivalent
representations.  Some useful ones serve a specific purpose.  Consider
for example the trivariate polynomial 4*x*y + x*z + 20*y^2 + 21*y*z +
4*z^2 (written down here in output-style).  It is equivalent to the
factorized polynomial (x + 5*y + 4*z)*(4*y + z).  Other representations
are the recursive ones where one collects for exponents in one of the
three variable.  Since the factors are themselves polynomials in the
remaining two variables the procedure can be repeated.  In our example,
two possibilities would be (4*y + z)*x + 20*y^2 + 21*y*z + 4*z^2 and
20*y^2 + (21*z + 4*x)*y + 4*z^2 + x*z.

To bring an expression into expanded form, its method

     ex ex::expand(unsigned options = 0);

may be called.  In our example above, this corresponds to 4*x*y + x*z +
20*y^2 + 21*y*z + 4*z^2.  Again, since the canonical form in GiNaC is
not easy to guess you should be prepared to see different orderings of
terms in such sums!

Another useful representation of multivariate polynomials is as a
univariate polynomial in one of the variables with the coefficients
being polynomials in the remaining variables.  The method `collect()'
accomplishes this task:

     ex ex::collect(const ex & s, bool distributed = false);

The first argument to `collect()' can also be a list of objects in which
case the result is either a recursively collected polynomial, or a
polynomial in a distributed form with terms like c*x1^e1*...*xn^en, as
specified by the `distributed' flag.

Note that the original polynomial needs to be in expanded form (for the
variables concerned) in order for `collect()' to be able to find the
coefficients properly.

The following `ginsh' transcript shows an application of `collect()'
together with `find()':

     > a=expand((sin(x)+sin(y))*(1+p+q)*(1+d));
     d*p*sin(x)+p*sin(x)+q*d*sin(x)+q*sin(y)+d*sin(x)+q*d*sin(y)+sin(y)+d*sin(y)
     +q*sin(x)+d*sin(y)*p+sin(x)+sin(y)*p
     > collect(a,{p,q});
     d*sin(x)+(d*sin(x)+sin(y)+d*sin(y)+sin(x))*p
     +(d*sin(x)+sin(y)+d*sin(y)+sin(x))*q+sin(y)+d*sin(y)+sin(x)
     > collect(a,find(a,sin($1)));
     (1+q+d+q*d+d*p+p)*sin(y)+(1+q+d+q*d+d*p+p)*sin(x)
     > collect(a,{find(a,sin($1)),p,q});
     (1+(1+d)*p+d+q*(1+d))*sin(x)+(1+(1+d)*p+d+q*(1+d))*sin(y)
     > collect(a,{find(a,sin($1)),d});
     (1+q+d*(1+q+p)+p)*sin(y)+(1+q+d*(1+q+p)+p)*sin(x)

Polynomials can often be brought into a more compact form by collecting
common factors from the terms of sums. This is accomplished by the
function

     ex collect_common_factors(const ex & e);

This function doesn't perform a full factorization but only looks for
factors which are already explicitly present:

     > collect_common_factors(a*x+a*y);
     (x+y)*a
     > collect_common_factors(a*x^2+2*a*x*y+a*y^2);
     a*(2*x*y+y^2+x^2)
     > collect_common_factors(a*(b*(a+c)*x+b*((a+c)*x+(a+c)*y)*y));
     (c+a)*a*(x*y+y^2+x)*b

Degree and coefficients
-----------------------

The degree and low degree of a polynomial can be obtained using the two
methods

     int ex::degree(const ex & s);
     int ex::ldegree(const ex & s);

which also work reliably on non-expanded input polynomials (they even
work on rational functions, returning the asymptotic degree). By
definition, the degree of zero is zero. To extract a coefficient with a
certain power from an expanded polynomial you use

     ex ex::coeff(const ex & s, int n);

You can also obtain the leading and trailing coefficients with the
methods

     ex ex::lcoeff(const ex & s);
     ex ex::tcoeff(const ex & s);

which are equivalent to `coeff(s, degree(s))' and `coeff(s,
ldegree(s))', respectively.

An application is illustrated in the next example, where a multivariate
polynomial is analyzed:

     {
         symbol x("x"), y("y");
         ex PolyInp = 4*pow(x,3)*y + 5*x*pow(y,2) + 3*y
                      - pow(x+y,2) + 2*pow(y+2,2) - 8;
         ex Poly = PolyInp.expand();
     
         for (int i=Poly.ldegree(x); i<=Poly.degree(x); ++i) {
             cout << "The x^" << i << "-coefficient is "
                  << Poly.coeff(x,i) << endl;
         }
         cout << "As polynomial in y: "
              << Poly.collect(y) << endl;
     }

When run, it returns an output in the following fashion:

     The x^0-coefficient is y^2+11*y
     The x^1-coefficient is 5*y^2-2*y
     The x^2-coefficient is -1
     The x^3-coefficient is 4*y
     As polynomial in y: -x^2+(5*x+1)*y^2+(-2*x+4*x^3+11)*y

As always, the exact output may vary between different versions of GiNaC
or even from run to run since the internal canonical ordering is not
within the user's sphere of influence.

`degree()', `ldegree()', `coeff()', `lcoeff()', `tcoeff()' and
`collect()' can also be used to a certain degree with non-polynomial
expressions as they not only work with symbols but with constants,
functions and indexed objects as well:

     {
         symbol a("a"), b("b"), c("c"), x("x");
         idx i(symbol("i"), 3);
     
         ex e = pow(sin(x) - cos(x), 4);
         cout << e.degree(cos(x)) << endl;
          // -> 4
         cout << e.expand().coeff(sin(x), 3) << endl;
          // -> -4*cos(x)
     
         e = indexed(a+b, i) * indexed(b+c, i);
         e = e.expand(expand_options::expand_indexed);
         cout << e.collect(indexed(b, i)) << endl;
          // -> a.i*c.i+(a.i+c.i)*b.i+b.i^2
     }

Polynomial division
-------------------

The two functions

     ex quo(const ex & a, const ex & b, const ex & x);
     ex rem(const ex & a, const ex & b, const ex & x);

compute the quotient and remainder of univariate polynomials in the
variable `x'. The results satisfy a = b*quo(a, b, x) + rem(a, b, x).

The additional function

     ex prem(const ex & a, const ex & b, const ex & x);

computes the pseudo-remainder of `a' and `b' which satisfies c*a = b*q
+ prem(a, b, x), where c = b.lcoeff(x) ^ (a.degree(x) - b.degree(x) +
1).

Exact division of multivariate polynomials is performed by the function

     bool divide(const ex & a, const ex & b, ex & q);

If `b' divides `a' over the rationals, this function returns `true' and
returns the quotient in the variable `q'. Otherwise it returns `false'
in which case the value of `q' is undefined.

Unit, content and primitive part
--------------------------------

The methods

     ex ex::unit(const ex & x);
     ex ex::content(const ex & x);
     ex ex::primpart(const ex & x);
     ex ex::primpart(const ex & x, const ex & c);

return the unit part, content part, and primitive polynomial of a
multivariate polynomial with respect to the variable `x' (the unit part
being the sign of the leading coefficient, the content part being the
GCD of the coefficients, and the primitive polynomial being the input
polynomial divided by the unit and content parts). The second variant
of `primpart()' expects the previously calculated content part of the
polynomial in `c', which enables it to work faster in the case where
the content part has already been computed. The product of unit,
content, and primitive part is the original polynomial.

Additionally, the method

     void ex::unitcontprim(const ex & x, ex & u, ex & c, ex & p);

computes the unit, content, and primitive parts in one go, returning
them in `u', `c', and `p', respectively.

GCD, LCM and resultant
----------------------

The functions for polynomial greatest common divisor and least common
multiple have the synopsis

     ex gcd(const ex & a, const ex & b);
     ex lcm(const ex & a, const ex & b);

The functions `gcd()' and `lcm()' accept two expressions `a' and `b' as
arguments and return a new expression, their greatest common divisor or
least common multiple, respectively.  If the polynomials `a' and `b'
are coprime `gcd(a,b)' returns 1 and `lcm(a,b)' returns the product of
`a' and `b'. Note that all the coefficients must be rationals.

     #include <ginac/ginac.h>
     using namespace GiNaC;
     
     int main()
     {
         symbol x("x"), y("y"), z("z");
         ex P_a = 4*x*y + x*z + 20*pow(y, 2) + 21*y*z + 4*pow(z, 2);
         ex P_b = x*y + 3*x*z + 5*pow(y, 2) + 19*y*z + 12*pow(z, 2);
     
         ex P_gcd = gcd(P_a, P_b);
         // x + 5*y + 4*z
         ex P_lcm = lcm(P_a, P_b);
         // 4*x*y^2 + 13*y*x*z + 20*y^3 + 81*y^2*z + 67*y*z^2 + 3*x*z^2 + 12*z^3
     }

The resultant of two expressions only makes sense with polynomials.  It
is always computed with respect to a specific symbol within the
expressions. The function has the interface

     ex resultant(const ex & a, const ex & b, const ex & s);

Resultants are symmetric in `a' and `b'. The following example computes
the resultant of two expressions with respect to `x' and `y',
respectively:

     #include <ginac/ginac.h>
     using namespace GiNaC;
     
     int main()
     {
         symbol x("x"), y("y");
     
         ex e1 = x+pow(y,2), e2 = 2*pow(x,3)-1; // x+y^2, 2*x^3-1
         ex r;
     
         r = resultant(e1, e2, x);
         // -> 1+2*y^6
         r = resultant(e1, e2, y);
         // -> 1-4*x^3+4*x^6
     }

Square-free decomposition
-------------------------

GiNaC still lacks proper factorization support.  Some form of
factorization is, however, easily implemented by noting that factors
appearing in a polynomial with power two or more also appear in the
derivative and hence can easily be found by computing the GCD of the
original polynomial and its derivatives.  Any decent system has an
interface for this so called square-free factorization.  So we provide
one, too:
     ex sqrfree(const ex & a, const lst & l = lst());
Here is an example that by the way illustrates how the exact form of the
result may slightly depend on the order of differentiation, calling for
some care with subsequent processing of the result:
         ...
         symbol x("x"), y("y");
         ex BiVarPol = expand(pow(2-2*y,3) * pow(1+x*y,2) * pow(x-2*y,2) * (x+y));
     
         cout << sqrfree(BiVarPol, lst(x,y)) << endl;
          // -> 8*(1-y)^3*(y*x^2-2*y+x*(1-2*y^2))^2*(y+x)
     
         cout << sqrfree(BiVarPol, lst(y,x)) << endl;
          // -> 8*(1-y)^3*(-y*x^2+2*y+x*(-1+2*y^2))^2*(y+x)
     
         cout << sqrfree(BiVarPol) << endl;
          // -> depending on luck, any of the above
         ...
Note also, how factors with the same exponents are not fully factorized
with this method.


File: ginac.info,  Node: Rational expressions,  Next: Symbolic differentiation,  Prev: Polynomial arithmetic,  Up: Methods and functions

Rational expressions
====================

The `normal' method
-------------------

Some basic form of simplification of expressions is called for
frequently.  GiNaC provides the method `.normal()', which converts a
rational function into an equivalent rational function of the form
`numerator/denominator' where numerator and denominator are coprime.
If the input expression is already a fraction, it just finds the GCD of
numerator and denominator and cancels it, otherwise it performs
fraction addition and multiplication.

`.normal()' can also be used on expressions which are not rational
functions as it will replace all non-rational objects (like functions
or non-integer powers) by temporary symbols to bring the expression to
the domain of rational functions before performing the normalization,
and re-substituting these symbols afterwards. This algorithm is also
available as a separate method `.to_rational()', described below.

This means that both expressions `t1' and `t2' are indeed simplified in
this little code snippet:

     {
         symbol x("x");
         ex t1 = (pow(x,2) + 2*x + 1)/(x + 1);
         ex t2 = (pow(sin(x),2) + 2*sin(x) + 1)/(sin(x) + 1);
         std::cout << "t1 is " << t1.normal() << std::endl;
         std::cout << "t2 is " << t2.normal() << std::endl;
     }

Of course this works for multivariate polynomials too, so the ratio of
the sample-polynomials from the section about GCD and LCM above would be
normalized to `P_a/P_b' = `(4*y+z)/(y+3*z)'.

Numerator and denominator
-------------------------

The numerator and denominator of an expression can be obtained with

     ex ex::numer();
     ex ex::denom();
     ex ex::numer_denom();

These functions will first normalize the expression as described above
and then return the numerator, denominator, or both as a list,
respectively.  If you need both numerator and denominator, calling
`numer_denom()' is faster than using `numer()' and `denom()' separately.

Converting to a polynomial or rational expression
-------------------------------------------------

Some of the methods described so far only work on polynomials or
rational functions. GiNaC provides a way to extend the domain of these
functions to general expressions by using the temporary replacement
algorithm described above. You do this by calling

     ex ex::to_polynomial(exmap & m);
     ex ex::to_polynomial(lst & l);
or
     ex ex::to_rational(exmap & m);
     ex ex::to_rational(lst & l);

on the expression to be converted. The supplied `exmap' or `lst' will
be filled with the generated temporary symbols and their replacement
expressions in a format that can be used directly for the `subs()'
method. It can also already contain a list of replacements from an
earlier application of `.to_polynomial()' or `.to_rational()', so it's
possible to use it on multiple expressions and get consistent results.

The difference between `.to_polynomial()' and `.to_rational()' is
probably best illustrated with an example:

     {
         symbol x("x"), y("y");
         ex a = 2*x/sin(x) - y/(3*sin(x));
         cout << a << endl;
     
         lst lp;
         ex p = a.to_polynomial(lp);
         cout << " = " << p << "\n   with " << lp << endl;
          // = symbol3*symbol2*y+2*symbol2*x
          //   with {symbol2==sin(x)^(-1),symbol3==-1/3}
     
         lst lr;
         ex r = a.to_rational(lr);
         cout << " = " << r << "\n   with " << lr << endl;
          // = -1/3*symbol4^(-1)*y+2*symbol4^(-1)*x
          //   with {symbol4==sin(x)}
     }

The following more useful example will print `sin(x)-cos(x)':

     {
         symbol x("x");
         ex a = pow(sin(x), 2) - pow(cos(x), 2);
         ex b = sin(x) + cos(x);
         ex q;
         exmap m;
         divide(a.to_polynomial(m), b.to_polynomial(m), q);
         cout << q.subs(m) << endl;
     }


File: ginac.info,  Node: Symbolic differentiation,  Next: Series expansion,  Prev: Rational expressions,  Up: Methods and functions

Symbolic differentiation
========================

GiNaC's objects know how to differentiate themselves.  Thus, a
polynomial (class `add') knows that its derivative is the sum of the
derivatives of all the monomials:

     {
         symbol x("x"), y("y"), z("z");
         ex P = pow(x, 5) + pow(x, 2) + y;
     
         cout << P.diff(x,2) << endl;
          // -> 20*x^3 + 2
         cout << P.diff(y) << endl;    // 1
          // -> 1
         cout << P.diff(z) << endl;    // 0
          // -> 0
     }

If a second integer parameter N is given, the `diff' method returns the
Nth derivative.

If _every_ object and every function is told what its derivative is,
all derivatives of composed objects can be calculated using the chain
rule and the product rule.  Consider, for instance the expression
`1/cosh(x)'.  Since the derivative of `cosh(x)' is `sinh(x)' and the
derivative of `pow(x,-1)' is `-pow(x,-2)', GiNaC can readily compute
the composition.  It turns out that the composition is the generating
function for Euler Numbers, i.e. the so called Nth Euler number is the
coefficient of `x^n/n!' in the expansion of `1/cosh(x)'.  We may use
this identity to code a function that generates Euler numbers in just
three lines:

     #include <ginac/ginac.h>
     using namespace GiNaC;
     
     ex EulerNumber(unsigned n)
     {
         symbol x;
         const ex generator = pow(cosh(x),-1);
         return generator.diff(x,n).subs(x==0);
     }
     
     int main()
     {
         for (unsigned i=0; i<11; i+=2)
             std::cout << EulerNumber(i) << std::endl;
         return 0;
     }

When you run it, it produces the sequence `1', `-1', `5', `-61',
`1385', `-50521'.  We increment the loop variable `i' by two since all
odd Euler numbers vanish anyways.


File: ginac.info,  Node: Series expansion,  Next: Symmetrization,  Prev: Symbolic differentiation,  Up: Methods and functions

Series expansion
================

Expressions know how to expand themselves as a Taylor series or (more
generally) a Laurent series.  As in most conventional Computer Algebra
Systems, no distinction is made between those two.  There is a class of
its own for storing such series (`class pseries') and a built-in
function (called `Order') for storing the order term of the series.  As
a consequence, if you want to work with series, i.e. multiply two
series, you need to call the method `ex::series' again to convert it to
a series object with the usual structure (expansion plus order term).
A sample application from special relativity could read:

     #include <ginac/ginac.h>
     using namespace std;
     using namespace GiNaC;
     
     int main()
     {
         symbol v("v"), c("c");
     
         ex gamma = 1/sqrt(1 - pow(v/c,2));
         ex mass_nonrel = gamma.series(v==0, 10);
     
         cout << "the relativistic mass increase with v is " << endl
              << mass_nonrel << endl;
     
         cout << "the inverse square of this series is " << endl
              << pow(mass_nonrel,-2).series(v==0, 10) << endl;
     }

Only calling the series method makes the last output simplify to
1-v^2/c^2+O(v^10), without that call we would just have a long series
raised to the power -2.

As another instructive application, let us calculate the numerical
value of Archimedes' constant Pi (for which there already exists the
built-in constant `Pi') using John Machin's amazing formula
Pi==16*atan(1/5)-4*atan(1/239).  This equation (and similar ones) were
used for over 200 years for computing digits of pi (see `Pi
Unleashed').  We may expand the arcus tangent around `0' and insert the
fractions `1/5' and `1/239'.  However, as we have seen, a series in
GiNaC carries an order term with it and the question arises what the
system is supposed to do when the fractions are plugged into that order
term.  The solution is to use the function `series_to_poly()' to simply
strip the order term off:

     #include <ginac/ginac.h>
     using namespace GiNaC;
     
     ex machin_pi(int degr)
     {
         symbol x;
         ex pi_expansion = series_to_poly(atan(x).series(x,degr));
         ex pi_approx = 16*pi_expansion.subs(x==numeric(1,5))
                        -4*pi_expansion.subs(x==numeric(1,239));
         return pi_approx;
     }
     
     int main()
     {
         using std::cout;  // just for fun, another way of...
         using std::endl;  // ...dealing with this namespace std.
         ex pi_frac;
         for (int i=2; i<12; i+=2) {
             pi_frac = machin_pi(i);
             cout << i << ":\t" << pi_frac << endl
                  << "\t" << pi_frac.evalf() << endl;
         }
         return 0;
     }

Note how we just called `.series(x,degr)' instead of
`.series(x==0,degr)'.  This is a simple shortcut for `ex''s method
`series()': if the first argument is a symbol the expression is
expanded in that symbol around point `0'.  When you run this program,
it will type out:

     2:      3804/1195
             3.1832635983263598326
     4:      5359397032/1706489875
             3.1405970293260603143
     6:      38279241713339684/12184551018734375
             3.141621029325034425
     8:      76528487109180192540976/24359780855939418203125
             3.141591772182177295
     10:     327853873402258685803048818236/104359128170408663038552734375
             3.1415926824043995174


File: ginac.info,  Node: Symmetrization,  Next: Built-in functions,  Prev: Series expansion,  Up: Methods and functions

Symmetrization
==============

The three methods

     ex ex::symmetrize(const lst & l);
     ex ex::antisymmetrize(const lst & l);
     ex ex::symmetrize_cyclic(const lst & l);

symmetrize an expression by returning the sum over all symmetric,
antisymmetric or cyclic permutations of the specified list of objects,
weighted by the number of permutations.

The three additional methods

     ex ex::symmetrize();
     ex ex::antisymmetrize();
     ex ex::symmetrize_cyclic();

symmetrize or antisymmetrize an expression over its free indices.

Symmetrization is most useful with indexed expressions but can be used
with almost any kind of object (anything that is `subs()'able):

     {
         idx i(symbol("i"), 3), j(symbol("j"), 3), k(symbol("k"), 3);
         symbol A("A"), B("B"), a("a"), b("b"), c("c");
     
         cout << indexed(A, i, j).symmetrize() << endl;
          // -> 1/2*A.j.i+1/2*A.i.j
         cout << indexed(A, i, j, k).antisymmetrize(lst(i, j)) << endl;
          // -> -1/2*A.j.i.k+1/2*A.i.j.k
         cout << lst(a, b, c).symmetrize_cyclic(lst(a, b, c)) << endl;
          // -> 1/3*{a,b,c}+1/3*{b,c,a}+1/3*{c,a,b}
     }


File: ginac.info,  Node: Built-in functions,  Next: Multiple polylogarithms,  Prev: Symmetrization,  Up: Methods and functions

Predefined mathematical functions
=================================

Overview
--------

GiNaC contains the following predefined mathematical functions:

*Name*                 *Function*
`abs(x)'               absolute value
`step(x)'              step function
`csgn(x)'              complex sign
`conjugate(x)'         complex conjugation
`real_part(x)'         real part
`imag_part(x)'         imaginary part
`sqrt(x)'              square root (not a GiNaC function, rather an
                       alias for `pow(x, numeric(1, 2))')
`sin(x)'               sine
`cos(x)'               cosine
`tan(x)'               tangent
`asin(x)'              inverse sine
`acos(x)'              inverse cosine
`atan(x)'              inverse tangent
`atan2(y, x)'          inverse tangent with two arguments
`sinh(x)'              hyperbolic sine
`cosh(x)'              hyperbolic cosine
`tanh(x)'              hyperbolic tangent
`asinh(x)'             inverse hyperbolic sine
`acosh(x)'             inverse hyperbolic cosine
`atanh(x)'             inverse hyperbolic tangent
`exp(x)'               exponential function
`log(x)'               natural logarithm
`Li2(x)'               dilogarithm
`Li(m, x)'             classical polylogarithm as well as multiple
                       polylogarithm
`G(a, y)'              multiple polylogarithm
`G(a, s, y)'           multiple polylogarithm with explicit signs for
                       the imaginary parts
`S(n, p, x)'           Nielsen's generalized polylogarithm
`H(m, x)'              harmonic polylogarithm
`zeta(m)'              Riemann's zeta function as well as multiple zeta
                       value
`zeta(m, s)'           alternating Euler sum
`zetaderiv(n, x)'      derivatives of Riemann's zeta function
`tgamma(x)'            gamma function
`lgamma(x)'            logarithm of gamma function
`beta(x, y)'           beta function (`tgamma(x)*tgamma(y)/tgamma(x+y)')
`psi(x)'               psi (digamma) function
`psi(n, x)'            derivatives of psi function (polygamma functions)
`factorial(n)'         factorial function n!
`binomial(n, k)'       binomial coefficients
`Order(x)'             order term function in truncated power series

For functions that have a branch cut in the complex plane GiNaC follows
the conventions for C++ as defined in the ANSI standard as far as
possible.  In particular: the natural logarithm (`log') and the square
root (`sqrt') both have their branch cuts running along the negative
real axis where the points on the axis itself belong to the upper part
(i.e. continuous with quadrant II).  The inverse trigonometric and
hyperbolic functions are not defined for complex arguments by the C++
standard, however.  In GiNaC we follow the conventions used by CLN,
which in turn follow the carefully designed definitions in the Common
Lisp standard.  It should be noted that this convention is identical to
the one used by the C99 standard and by most serious CAS.  It is to be
expected that future revisions of the C++ standard incorporate these
functions in the complex domain in a manner compatible with C99.

